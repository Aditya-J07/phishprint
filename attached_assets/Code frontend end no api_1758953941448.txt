# PhishPrint - Complete Replit Setup Instructions

## STEP 1: Create New Replit Project

1. Go to replit.com and create a new Python project
2. Name it: `PhishPrint-Security-Suite`
3. Copy and paste the files below exactly as shown

## STEP 2: Create these files in your Replit:

### File 1: `main.py` (Main application entry point)
```python
import streamlit as st
import subprocess
import sys
import os

# Configure Streamlit to run on correct port for Replit
def setup_streamlit():
    os.system("streamlit run app.py --server.port 8080 --server.address 0.0.0.0")

if __name__ == "__main__":
    setup_streamlit()
```

### File 2: `app.py` (Main PhishPrint application)
```python
"""
PhishPrint - Complete Email Security Suite
Integrated Gmail-like interface with AI security analysis
"""

import streamlit as st
import pandas as pd
import numpy as np
from sklearn.ensemble import IsolationForest
from sklearn.feature_extraction.text import TfidfVectorizer
import re
import json
from datetime import datetime, timedelta
import plotly.express as px
import plotly.graph_objects as go
import time

# Configure page
st.set_page_config(
    page_title="PhishPrint Security Suite", 
    page_icon="üõ°Ô∏è", 
    layout="wide",
    initial_sidebar_state="collapsed"
)

class EmailSecurityEngine:
    def __init__(self):
        self.phish_model = IsolationForest(contamination=0.1, random_state=42)
        self.user_baseline = None
        self.vectorizer = TfidfVectorizer(max_features=50, stop_words='english')
        
        # Phishing patterns
        self.phish_keywords = [
            'urgent', 'immediate action', 'verify account', 'suspended',
            'click here now', 'limited time', 'congratulations', 'winner',
            'free money', 'claim now', 'act fast', 'expires today'
        ]
        
        # Code injection patterns
        self.injection_patterns = [
            r'<script.*?>.*?</script>',
            r'javascript:',
            r'eval\(',
            r'document\.write',
            r'window\.open',
            r'onclick\s*=',
            r'onerror\s*=',
            r'onload\s*='
        ]
        
        # Initialize with demo data
        self.setup_demo_data()
    
    def setup_demo_data(self):
        # Create realistic email history for training
        historical_emails = []
        base_time = datetime.now() - timedelta(days=30)
        
        for i in range(40):
            email_time = base_time + timedelta(days=i*0.7, hours=np.random.normal(11, 2))
            historical_emails.append({
                'timestamp': email_time,
                'sender': np.random.choice(['team@company.com', 'hr@company.com', 'client@partner.com']),
                'body': f"Hi, wanted to update you on project status. Everything is progressing well. Best regards.",
                'subject': f"Project Update {i}"
            })
        
        self.train_baseline(historical_emails)
        
        # Demo emails for testing
        self.demo_emails = {
            "üìß Normal Work Email": {
                'from': 'colleague@company.com',
                'subject': 'Weekly Team Meeting Tomorrow',
                'body': 'Hi everyone, reminder about our weekly team meeting tomorrow at 2 PM in conference room A. We will discuss project progress and plan for next week.',
                'timestamp': datetime.now() - timedelta(hours=1),
                'risk_level': 'low'
            },
            "‚ö†Ô∏è Obvious Phishing Attempt": {
                'from': 'security@bank-urgent.suspicious.net',
                'subject': 'URGENT: Account Suspended - Immediate Action Required!!!',
                'body': 'Your bank account has been suspended due to suspicious activity! Click here NOW to verify: http://bit.ly/fake-bank. Act fast or lose access forever! Limited time offer expires in 24 hours!',
                'timestamp': datetime.now() - timedelta(hours=2),
                'risk_level': 'high'
            },
            "üéØ Sophisticated Spear Phishing": {
                'from': 'colleague@company.com',
                'subject': 'Quick Financial Approval Needed',
                'body': 'Hi, I know this is last minute but I need urgent approval for vendor payment. CEO is traveling and this needs to be done today. Please click here to approve: http://finance-portal.fake-company.com/approve',
                'timestamp': datetime(2024, 1, 15, 2, 30),
                'risk_level': 'high'
            },
            "üíª Code Injection Attempt": {
                'from': 'newsletter@techsite.com',
                'subject': 'New JavaScript Tutorial',
                'body': 'Check out our latest tutorial! <script>eval(atob("d2luZG93LmxvY2F0aW9uPSJodHRwOi8vbWFsaWNpb3VzLXNpdGUuY29tIjs="))</script> Click here for more: http://techsite.com/tutorial',
                'timestamp': datetime.now() - timedelta(hours=3),
                'risk_level': 'high'
            }
        }
    
    def train_baseline(self, emails):
        if len(emails) < 5:
            return
        
        features = []
        for email in emails:
            features.append(self.extract_features(email))
        
        if features:
            self.phish_model.fit(features)
            self.user_baseline = {
                'total_emails': len(emails),
                'avg_length': np.mean([len(e['body']) for e in emails]),
                'common_hour': np.bincount([e['timestamp'].hour for e in emails]).argmax()
            }
    
    def extract_features(self, email):
        body = email.get('body', '')
        timestamp = email.get('timestamp', datetime.now())
        
        return [
            timestamp.hour,
            timestamp.weekday(),
            len(body),
            body.count('!'),
            body.count('http'),
            sum(1 for word in self.phish_keywords if word.lower() in body.lower()),
            len(re.findall(r'[A-Z]', body)) / max(len(body), 1)
        ]
    
    def analyze_phishing(self, email):
        score = 0
        flags = []
        
        body = email.get('body', '').lower()
        
        # Keyword analysis
        for keyword in self.phish_keywords:
            if keyword.lower() in body:
                score += 15
                flags.append(f"Suspicious keyword: '{keyword}'")
        
        # URL analysis
        urls = re.findall(r'http[s]?://[^\s]+', body)
        for url in urls:
            if any(suspicious in url.lower() for suspicious in ['bit.ly', 'tinyurl', 'fake', 'suspicious']):
                score += 20
                flags.append(f"Suspicious URL detected")
        
        # ML analysis
        if self.user_baseline:
            features = [self.extract_features(email)]
            anomaly_score = self.phish_model.decision_function(features)[0]
            if anomaly_score < -0.1:
                ml_contribution = min(30, abs(anomaly_score) * 100)
                score += ml_contribution
                flags.append("Unusual communication pattern detected")
        
        return min(score, 100), flags
    
    def analyze_code_injection(self, email):
        score = 0
        flags = []
        
        body = email.get('body', '')
        
        for pattern in self.injection_patterns:
            matches = re.findall(pattern, body, re.IGNORECASE | re.DOTALL)
            if matches:
                score += 25
                flags.append(f"Code injection pattern detected: {pattern[:20]}...")
        
        # Check for encoded payloads
        if 'atob(' in body or 'fromCharCode(' in body:
            score += 30
            flags.append("Encoded payload detected")
        
        return min(score, 100), flags
    
    def get_risk_color(self, score):
        if score >= 70:
            return "red", "HIGH RISK"
        elif score >= 40:
            return "orange", "MEDIUM RISK"
        else:
            return "green", "LOW RISK"

class PhishPrintUI:
    def __init__(self):
        self.engine = EmailSecurityEngine()
        self.selected_email = None
        
    def render_gmail_interface(self):
        # Custom CSS for Gmail-like appearance
        st.markdown("""
        <style>
        .email-item {
            border: 1px solid #e0e0e0;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
        }
        .email-item:hover {
            background-color: #f5f5f5;
        }
        .risk-high { border-left: 5px solid red; }
        .risk-medium { border-left: 5px solid orange; }
        .risk-low { border-left: 5px solid green; }
        
        .phish-score {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 15px;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }
        .score-high { background-color: red; }
        .score-medium { background-color: orange; }
        .score-low { background-color: green; }
        </style>
        """, unsafe_allow_html=True)
        
        # Header
        st.markdown("# üõ°Ô∏è PhishPrint Security Suite")
        st.markdown("*Gmail-Integrated AI Email Security Assistant*")
        
        # Main layout
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.markdown("## üì¨ Inbox")
            
            # Email list
            for email_name, email_data in self.engine.demo_emails.items():
                # Analyze email
                phish_score, phish_flags = self.engine.analyze_phishing(email_data)
                code_score, code_flags = self.engine.analyze_code_injection(email_data)
                total_score = min(phish_score + code_score, 100)
                
                color, risk_level = self.engine.get_risk_color(total_score)
                
                # Email item
                with st.container():
                    if st.button(f"{email_name}", key=email_name, use_container_width=True):
                        self.selected_email = (email_name, email_data, total_score, phish_flags + code_flags, risk_level)
                    
                    # Show preview with risk indicator
                    col_a, col_b = st.columns([3, 1])
                    with col_a:
                        st.markdown(f"**From:** {email_data['from']}")
                        st.markdown(f"**Subject:** {email_data['subject']}")
                        st.markdown(f"{email_data['body'][:100]}...")
                    with col_b:
                        if color == "red":
                            st.error(f"üö® {total_score:.0f}/100")
                        elif color == "orange":
                            st.warning(f"‚ö†Ô∏è {total_score:.0f}/100")
                        else:
                            st.success(f"‚úÖ {total_score:.0f}/100")
                    
                    st.markdown("---")
        
        with col2:
            if self.selected_email:
                self.render_analysis_panel()
            else:
                st.markdown("## üîç Analysis Panel")
                st.info("Select an email to see detailed security analysis")
    
    def render_analysis_panel(self):
        email_name, email_data, score, flags, risk_level = self.selected_email
        
        st.markdown("## üîç Security Analysis")
        
        # Risk gauge
        fig = go.Figure(go.Indicator(
            mode = "gauge+number",
            value = score,
            title = {'text': "PhishScore"},
            domain = {'x': [0, 1], 'y': [0, 1]},
            gauge = {
                'axis': {'range': [None, 100]},
                'bar': {'color': "red" if score >= 70 else "orange" if score >= 40 else "green"},
                'steps': [
                    {'range': [0, 40], 'color': "lightgreen"},
                    {'range': [40, 70], 'color': "lightyellow"},
                    {'range': [70, 100], 'color': "lightcoral"}
                ]
            }
        ))
        fig.update_layout(height=250)
        st.plotly_chart(fig, use_container_width=True)
        
        # Risk level
        if score >= 70:
            st.error(f"üö® **{risk_level}**")
        elif score >= 40:
            st.warning(f"‚ö†Ô∏è **{risk_level}**")
        else:
            st.success(f"‚úÖ **{risk_level}**")
        
        # Detailed flags
        if flags:
            st.markdown("### üö© Security Flags:")
            for flag in flags:
                st.markdown(f"‚Ä¢ {flag}")
        
        # Interactive chat
        st.markdown("### üí¨ Ask PhishPrint")
        user_question = st.text_input("Ask about this email:", key="chat_input")
        
        if user_question:
            response = self.generate_chat_response(user_question, email_name, score, flags)
            st.markdown(f"**PhishPrint:** {response}")
    
    def generate_chat_response(self, question, email_name, score, flags):
        question_lower = question.lower()
        
        if "safe" in question_lower:
            if score >= 70:
                return "‚ùå This email is NOT safe. Multiple security threats detected."
            elif score >= 40:
                return "‚ö†Ô∏è This email has moderate risk. Exercise caution."
            else:
                return "‚úÖ This email appears safe based on analysis."
        
        elif "why" in question_lower and "score" in question_lower:
            if flags:
                return f"Score based on: {', '.join(flags[:3])}. Check detailed analysis above."
            else:
                return "Low score due to normal communication patterns and no red flags."
        
        elif "code" in question_lower or "script" in question_lower:
            if any("injection" in flag.lower() for flag in flags):
                return "üö® YES - Malicious code detected! This email contains script injection attempts."
            else:
                return "‚úÖ No malicious code detected in this email."
        
        elif "sender" in question_lower:
            return f"Analyzing sender patterns and domain reputation in security assessment."
        
        else:
            return "I can help explain the security analysis. Ask about safety, score reasons, code threats, or sender verification."

def main():
    ui = PhishPrintUI()
    ui.render_gmail_interface()

if __name__ == "__main__":
    main()
```

### File 3: `requirements.txt`
```txt
streamlit==1.28.1
pandas==1.5.3
numpy==1.24.3
scikit-learn==1.3.0
plotly==5.15.0
python-dateutil==2.8.2
```

### File 4: `.replit` (Configuration file)
```toml
run = "python main.py"

[nix]
channel = "stable-22_11"

[deployment]
run = ["sh", "-c", "python main.py"]
```

### File 5: `replit.nix`
```nix
{ pkgs }: {
  deps = [
    pkgs.python310Full
    pkgs.replitPackages.prybar-python310
    pkgs.replitPackages.stderred
  ];
  env = {
    PYTHON_LD_LIBRARY_PATH = pkgs.lib.makeLibraryPath [
      # Needed for pandas / numpy
      pkgs.stdenv.cc.cc.lib
      pkgs.zlib
      # Needed for pygame
      pkgs.glib
    ];
    PYTHONHOME = "${pkgs.python310Full}";
    PYTHONBIN = "${pkgs.python310Full}/bin/python3.10";
    LANG = "en_US.UTF-8";
    STDERREDBIN = "${pkgs.replitPackages.stderred}/bin/stderred";
    PRYBAR_PYTHON_BIN = "${pkgs.replitPackages.prybar-python310}/bin/prybar-python310";
  };
}
```

## STEP 3: Run the Project

1. Click the "Run" button in Replit
2. Wait for packages to install (first run takes 2-3 minutes)
3. The app will open in a new tab automatically
4. Share the URL with judges for live demo

## STEP 4: What You Should Do Next

### Immediate Actions:
1. **Test all demo emails** - Make sure each shows different risk levels
2. **Practice the demo flow** - Show normal ‚Üí obvious phishing ‚Üí spear phishing ‚Üí code injection
3. **Prepare talking points** about personalization and education features

### Before Presentation:
1. **Add your team info** in the app header
2. **Customize demo emails** with more realistic content for your use case
3. **Test the chat responses** - make sure they're helpful and educational

### Demo Script:
1. "This is PhishPrint - AI email security that learns YOUR patterns"
2. Show normal email getting low score
3. Show obvious phishing getting caught
4. Show sophisticated spear phishing - "Traditional filters miss this"
5. Show code injection detection
6. Demonstrate interactive chat asking questions
7. Explain market opportunity and technical innovation

### Technical Backup Plan:
- If Replit is slow during presentation, record a video backup
- Have screenshots ready of all major features
- Prepare to explain the technical approach without live demo if needed

The app will be live at your Replit URL and ready for judges to interact with immediately!